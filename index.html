<!DOCTYPE html>
<html lang="uz">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>XOLERIC  CORE</title>
<style>
:root {
    --primary:#00ff88;
    --bg-color:#050505;
}
body{
    margin:0; padding:0; overflow:hidden; background-color:var(--bg-color);
    font-family:'Courier New', monospace; user-select:none;
}
#canvas-container{ position:fixed; top:0; left:0; width:100%; height:100%; z-index:1; }
#ui-layer{
    position:fixed; top:0; left:0; width:100%; height:100%; z-index:2; pointer-events:none;
    padding:40px; box-sizing:border-box; display:flex; flex-direction:column; justify-content:space-between;
    opacity:0; transform:scale(0.5); transition: all 1s ease-out;
}
.hud-text{ color:rgba(255,255,255,0.5); font-size:12px; letter-spacing:2px; }
.hud-title{ color:#fff; font-size:18px; font-weight:bold; text-shadow:0 0 10px rgba(255,255,255,0.5); }
</style>
<script type="importmap">
{
    "imports":{
        "three":"https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/":"https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>
</head>
<body>
<div id="ui-layer">
    <div class="hud-top">
        <div class="hud-title">XOLERIC</div>
        <div class="hud-text">neural core online</div>
    </div>
    <div class="hud-bottom">
        <div class="hud-text">xoleric</div>
        <div class="hud-text" id="fps-counter">Ï€</div>
    </div>
</div>
<div id="canvas-container"></div>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

class XolericNeuralCore {
    constructor(){
        this.container=document.getElementById('canvas-container');
        this.width=window.innerWidth; this.height=window.innerHeight;
        this.mouse=new THREE.Vector2(); this.targetRotation=new THREE.Vector2();
        this.windowHalfX=this.width/2; this.windowHalfY=this.height/2;
        this.time=0; this.hue=0; this.uiShown=false;

        this.init();
        this.addCoreCube();
        this.addNeuralNetwork();
        this.initPostProcessing();
        this.addMatrixBackground();
        this.addEventListeners();
        this.animate();
    }

    init(){
        this.scene=new THREE.Scene(); 
        this.scene.fog=new THREE.FogExp2(0x000000,0.02);

        this.camera=new THREE.PerspectiveCamera(50,this.width/this.height,0.1,100);
        this.camera.position.z=5;

        this.renderer=new THREE.WebGLRenderer({antialias:true, alpha:true});
        this.renderer.setSize(this.width,this.height); 
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
        this.renderer.toneMapping=THREE.ReinhardToneMapping; 
        this.container.appendChild(this.renderer.domElement);

        const ambientLight=new THREE.AmbientLight(0x404040,2); this.scene.add(ambientLight);
        this.pointLight1=new THREE.PointLight(0xffffff,50,20); this.pointLight1.position.set(2,2,2); this.scene.add(this.pointLight1);
        this.pointLight2=new THREE.PointLight(0xffffff,50,20); this.pointLight2.position.set(-2,-2,2); this.scene.add(this.pointLight2);
    }

    addCoreCube(){
        const coreGeometry=new THREE.BoxGeometry(1.4,1.4,1.4);
        const canvas=document.createElement('canvas'); canvas.width=512; canvas.height=512;
        this.texCtx=canvas.getContext('2d'); this.canvasTexture=new THREE.CanvasTexture(canvas);
        this.coreMaterial=new THREE.MeshPhysicalMaterial({
            map:this.canvasTexture,color:0xffffff,metalness:0.1,roughness:0.05,transmission:0.6,thickness:1.5,
            emissive:0x000000,emissiveIntensity:1,clearcoat:1,clearcoatRoughness:0.1
        });
        this.coreCube=new THREE.Mesh(coreGeometry,this.coreMaterial); this.scene.add(this.coreCube);

        const cageGeometry=new THREE.BoxGeometry(1.8,1.8,1.8);
        const cageMaterial=new THREE.MeshBasicMaterial({color:0x00ff88,wireframe:true,transparent:true,opacity:0.3});
        this.cage=new THREE.Mesh(cageGeometry,cageMaterial); this.scene.add(this.cage);
    }

    addNeuralNetwork(){
        this.neurons=[]; const neuronCount=90;
        const neuronGeo=new THREE.SphereGeometry(0.03,6,6);
        for(let i=0;i<neuronCount;i++){
            const neuron=new THREE.Mesh(neuronGeo,new THREE.MeshBasicMaterial({color:0x00ff88,emissive:0x00ff88}));
            neuron.position.set((Math.random()-0.5)*1.2,(Math.random()-0.5)*1.2,(Math.random()-0.5)*1.2);
            neuron.scale.set(0.01,0.01,0.01); // boshi kichik
            this.scene.add(neuron);
            this.neurons.push({mesh:neuron,vel:new THREE.Vector3((Math.random()-0.5)*0.005,(Math.random()-0.5)*0.005,(Math.random()-0.5)*0.005)});
        }

        this.neuronLinesGeo=new THREE.BufferGeometry();
        const positions=new Float32Array(neuronCount*neuronCount*3*2);
        this.neuronLinesGeo.setAttribute('position',new THREE.BufferAttribute(positions,3));
        this.neuronLinesMat=new THREE.LineBasicMaterial({color:0x00ff88,transparent:true,opacity:0.2});
        this.neuronLines=new THREE.LineSegments(this.neuronLinesGeo,this.neuronLinesMat); 
        this.scene.add(this.neuronLines);
    }

    initPostProcessing(){
        const renderScene=new RenderPass(this.scene,this.camera);
        const bloomPass=new UnrealBloomPass(new THREE.Vector2(this.width,this.height),1.5,0.4,0.85);
        bloomPass.strength=1.8;bloomPass.radius=0.5;bloomPass.threshold=0.1;
        this.composer=new EffectComposer(this.renderer); 
        this.composer.addPass(renderScene); this.composer.addPass(bloomPass);
    }

    addMatrixBackground(){
        this.bgCanvas=document.createElement('canvas'); this.bgCanvas.style.position='fixed'; 
        this.bgCanvas.style.top='0'; this.bgCanvas.style.left='0'; this.bgCanvas.style.zIndex='0'; 
        this.bgCanvas.style.opacity='0.2'; document.body.appendChild(this.bgCanvas);
        this.bgCtx=this.bgCanvas.getContext('2d'); this.matrixDrops=[]; this.resizeMatrix();
        const columns=this.bgCanvas.width/20; for(let i=0;i<columns;i++) this.matrixDrops[i]=1;
    }

    resizeMatrix(){ this.bgCanvas.width=window.innerWidth; this.bgCanvas.height=window.innerHeight; }
    updateMatrix(){
        this.bgCtx.fillStyle='rgba(0,0,0,0.05)'; this.bgCtx.fillRect(0,0,this.bgCanvas.width,this.bgCanvas.height);
        this.bgCtx.fillStyle=`hsl(${this.hue},100%,50%)`; this.bgCtx.font='15px monospace';
        const chars="XOLERIC01"; for(let i=0;i<this.matrixDrops.length;i++){
            const text=chars[Math.floor(Math.random()*chars.length)];
            this.bgCtx.fillText(text,i*20,this.matrixDrops[i]*20);
            if(this.matrixDrops[i]*20>this.bgCanvas.height && Math.random()>0.975)this.matrixDrops[i]=0;
            this.matrixDrops[i]++;
        }
    }

    updateTexture(time){
        this.texCtx.fillStyle='#000'; this.texCtx.fillRect(0,0,512,512);
        this.texCtx.lineWidth=10; this.texCtx.strokeStyle=`hsl(${this.hue},100%,50%)`; this.texCtx.strokeRect(20,20,472,472);
        this.texCtx.font='bold 50px Courier New'; this.texCtx.textAlign='center'; this.texCtx.textBaseline='middle';
        this.texCtx.fillStyle=`hsl(${this.hue},100%,70%)`;
        this.texCtx.fillText("xoleric",256,256);
        this.canvasTexture.needsUpdate=true;
    }

    addEventListeners(){
        window.addEventListener('resize',this.onWindowResize.bind(this));
        document.addEventListener('mousemove',this.onDocumentMouseMove.bind(this));
        document.addEventListener('touchmove',this.onTouchMove.bind(this),{passive:false});
        document.addEventListener('scroll',this.onScroll.bind(this));
    }

    onWindowResize(){ 
        this.width=window.innerWidth; this.height=window.innerHeight;
        this.windowHalfX=this.width/2; this.windowHalfY=this.height/2;
        this.camera.aspect=this.width/this.height; this.camera.updateProjectionMatrix();
        this.renderer.setSize(this.width,this.height); this.composer.setSize(this.width,this.height); this.resizeMatrix();
    }
    onDocumentMouseMove(e){ this.mouse.x=(e.clientX-this.windowHalfX)*0.001; this.mouse.y=(e.clientY-this.windowHalfY)*0.001; }
    onTouchMove(e){ if(e.touches.length>0){ e.preventDefault(); this.mouse.x=(e.touches[0].clientX-this.windowHalfX)*0.002; this.mouse.y=(e.touches[0].clientY-this.windowHalfY)*0.002; } }
    onScroll(){ const scrollFactor=window.scrollY*0.001; this.coreCube.rotation.x+=scrollFactor; this.coreCube.rotation.y+=scrollFactor; }

    animate(){
        requestAnimationFrame(this.animate.bind(this));
        this.time+=0.01; this.hue=(this.hue+0.5)%360;

        const color=new THREE.Color(`hsl(${this.hue},100%,50%)`);
        this.cage.material.color=color; this.coreMaterial.emissive=new THREE.Color(`hsl(${this.hue},100%,20%)`);
        this.pointLight1.color=color; this.pointLight2.color=new THREE.Color(`hsl(${(this.hue+180)%360},100%,50%)`);

        // Kub smooth rotation
        this.targetRotation.x=this.mouse.y*5; this.targetRotation.y=this.mouse.x*5;
        this.coreCube.rotation.x+=(this.targetRotation.x-this.coreCube.rotation.x)*0.05;
        this.coreCube.rotation.y+=(this.targetRotation.y-this.coreCube.rotation.y)*0.05;
        this.coreCube.rotation.z+=0.005; this.cage.rotation.copy(this.coreCube.rotation); this.cage.rotation.x*=-1;

        // Neurons growth animation
        let completeCount=0;
        this.neurons.forEach(n=>{
            n.mesh.scale.x=Math.min(n.mesh.scale.x+0.02,1);
            n.mesh.scale.y=Math.min(n.mesh.scale.y+0.02,1);
            n.mesh.scale.z=Math.min(n.mesh.scale.z+0.02,1);
            n.mesh.position.add(n.vel);
            for(const axis of ['x','y','z']){
                if(n.mesh.position[axis]>0.7 || n.mesh.position[axis]<-0.7) n.vel[axis]*=-1;
            }
            if(n.mesh.scale.x>=1) completeCount++;
        });

        if(!this.uiShown && completeCount===this.neurons.length){
            this.uiShown=true;
            document.getElementById('ui-layer').style.opacity='1';
            document.getElementById('ui-layer').style.transform='scale(1)';
        }

        // Lines between neurons
        const positions=this.neuronLinesGeo.attributes.position.array; let idx=0;
        for(let i=0;i<this.neurons.length;i++){
            for(let j=i+1;j<this.neurons.length;j++){
                const dist=this.neurons[i].mesh.position.distanceTo(this.neurons[j].mesh.position);
                if(dist<0.35){
                    positions[idx++]=this.neurons[i].mesh.position.x; positions[idx++]=this.neurons[i].mesh.position.y; positions[idx++]=this.neurons[i].mesh.position.z;
                    positions[idx++]=this.neurons[j].mesh.position.x; positions[idx++]=this.neurons[j].mesh.position.y; positions[idx++]=this.neurons[j].mesh.position.z;
                }
            }
        }
        this.neuronLinesGeo.setDrawRange(0,idx/3); this.neuronLinesGeo.attributes.position.needsUpdate=true;

        this.updateTexture(this.time); this.updateMatrix(); this.composer.render();
    }
}

new XolericNeuralCore();
</script>
</body>
</html>
